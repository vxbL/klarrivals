-- Safe Orion load
local success, Orion = pcall(function()
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/shlexware/Orion/main/source"))()
end)

if not success or not Orion then
    warn("Orion failed to load.")
    return
end

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

-- Dynamic Camera and Character handling
local function getCamera()
    local cam = workspace.CurrentCamera
    if not cam then
        repeat wait(0.1) cam = workspace.CurrentCamera until cam
    end
    return cam
end

local Camera = getCamera()
local LocalCharacter = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
LocalPlayer.CharacterAdded:Connect(function(char)
    LocalCharacter = char
    warn("Character updated: " .. tostring(LocalCharacter))
    -- Clear ESP elements on character change
    for player, elements in pairs(espElements) do
        if elements then
            for _, obj in pairs(elements) do
                if obj and obj.Remove then obj:Remove() end
            end
        end
        espElements[player] = nil
    end
end)

-- Modules
local Utility = require(ReplicatedStorage.Modules.Utility)

-- ESP config
local esp_enabled = true
local box_color = Color3.fromRGB(255, 255, 255)
local name_color = Color3.fromRGB(255, 255, 255)
local hp_color = Color3.fromRGB(0, 255, 0)
local team_color = Color3.fromRGB(0, 0, 255)
local esp_max_distance = 1000
local espElements = {}
local esp_team_check = true
local esp_visible_check = false

-- Aimbot config
local aimbot_enabled = false
local aimbot_key_name = "MouseButton2"
local aimbot_key_code = Enum.UserInputType.MouseButton2
local aimbot_aim_part = "Head"
local aimbot_fov_size = 100
local aimbot_smoothness = 1
local show_fov_circle = true
local aimbot_held = false
local aimbot_max_distance = 1000
local aimbot_target_method = "Distance"
local aimbot_team_check = true
local aimbot_visible_check = false

-- Silent Aim config
local silent_aim_enabled = false
local silent_aim_key_name = "MouseButton1"
local silent_aim_key_code = Enum.UserInputType.MouseButton1
local silent_aim_fov = 100
local silent_aim_part = "Head"
local silent_aim_hit_chance = 100
local silent_aim_max_distance = 1000
local silent_aim_held = false
local silent_aim_target_method = "Distance"
local silent_aim_team_check = true
local silent_aim_visible_check = false

-- Aim part mapping
local aimPartMapping = {
    Head = {"Head", "HumanoidRootPart"},
    UpperTorso = {"UpperTorso", "HumanoidRootPart"},
    LowerTorso = {"LowerTorso", "HumanoidRootPart"},
    HumanoidRootPart = {"HumanoidRootPart"}
}

local function areOnSameTeam(player1, player2)
    if not player1 or not player2 then return false end
    local team1, team2 = player1.Team, player2.Team
    local teamAttr1 = player1:GetAttribute("Team") or (player1:FindFirstChild("Leaderstats") and player1.Leaderstats:FindFirstChild("Team") and player1.Leaderstats.Team.Value)
    local teamAttr2 = player2:GetAttribute("Team") or (player2:FindFirstChild("Leaderstats") and player2.Leaderstats:FindFirstChild("Team") and player2.Leaderstats.Team.Value)
    if team1 and team2 and team1 == team2 then return true end
    if teamAttr1 and teamAttr2 and teamAttr1 == teamAttr2 then return true end
    return false
end

-- Function to get a valid aim part
local function getValidAimPart(character, aimPart)
    if not character then
        warn("No character found for aim part validation")
        return nil
    end
    local possibleParts = aimPartMapping[aimPart] or {aimPart}
    for _, partName in ipairs(possibleParts) do
        local part = character:FindFirstChild(partName)
        if part then return part end
    end
    warn("No valid aim part found, falling back to HumanoidRootPart")
    return character:FindFirstChild("HumanoidRootPart")
end

-- Function to calculate distance
local function getDistance(pos1, pos2)
    return (pos1 - pos2).Magnitude
end

-- Improved visible check function
local function isVisible(origin, targetPosition, targetCharacter)
    if not origin or not targetPosition or not targetCharacter then
        warn("Invalid parameters for visibility check: origin=" .. tostring(origin) .. ", targetPosition=" .. tostring(targetPosition) .. ", targetCharacter=" .. tostring(targetCharacter))
        return false
    end

    -- Raycast parameters
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    -- Blacklist local player's character and its descendants to avoid self-collision
    local filter = {LocalPlayer.Character}
    if LocalPlayer.Character then
        for _, descendant in ipairs(LocalPlayer.Character:GetDescendants()) do
            if descendant:IsA("BasePart") then
                table.insert(filter, descendant)
            end
        end
    end
    -- Add transparent parts of the target character to the blacklist
    for _, part in ipairs(targetCharacter:GetDescendants()) do
        if part:IsA("BasePart") and part.Transparency >= 0.9 then
            table.insert(filter, part)
        end
    end
    rayParams.FilterDescendantsInstances = filter
    rayParams.IgnoreWater = true
    rayParams.RespectCanCollide = true

    -- Calculate direction and distance
    local direction = targetPosition - origin
    local distance = direction.Magnitude
    if distance < 0.1 then
        return true -- Target is too close, consider visible
    end
    direction = direction.Unit * distance

    -- Perform raycast
    local success, result = pcall(function()
        return Workspace:Raycast(origin, direction, rayParams)
    end)

    if not success then
        warn("Raycast failed: " .. tostring(result))
        return false
    end

    if result then
        -- Check if the hit instance is part of the target character
        local hitInstance = result.Instance
        if hitInstance and hitInstance:IsDescendantOf(targetCharacter) then
            return true
        end
        -- Additional check for partial visibility (e.g., through semi-transparent objects)
        if hitInstance.Transparency < 0.9 then
            return false -- Opaque object blocks the view
        end
    end

    return true -- No obstruction or hit instance is part of target
end

-- Drawing circle for FOV
local fovCircleCreated = false
local fovCircle

local function createFOVCircle()
    if not fovCircleCreated then
        fovCircle = Drawing.new("Circle")
        fovCircle.Color = Color3.fromRGB(255, 0, 0)
        fovCircle.Thickness = 2
        fovCircle.Filled = false
        fovCircle.Transparency = 1
        fovCircle.Radius = math.max(aimbot_fov_size, silent_aim_fov)
        fovCircle.Visible = false
        fovCircleCreated = true
    end
end

createFOVCircle()

-- Create Orion window
local Window = Orion:MakeWindow({
    Name = "KLAR Rivals",
    LoadingTitle = "KLAR Rivals",
    LoadingSubtitle = "By Vxibility",
    ConfigurationSaving = {Enabled = false},
    KeySystem = false
})

-- Create tabs
local ESPTab = Window:MakeTab({
    Name = "ESP",
    Icon = "rbxassetid://4483362458",
    PremiumOnly = false
})

local AimbotTab = Window:MakeTab({
    Name = "Aimbot",
    Icon = "rbxassetid://4483362300",
    PremiumOnly = false
})

local SilentAimTab = Window:MakeTab({
    Name = "Silent Aim",
    Icon = "rbxassetid://4483362300",
    PremiumOnly = false
})

local ConfigTab = Window:MakeTab({
    Name = "Config",
    Icon = "rbxassetid://4483362458",
    PremiumOnly = false
})

-- ESP Tab elements
ESPTab:AddSection("ESP Controls")

ESPTab:AddToggle("Enable ESP", {
    Default = true,
    Callback = function(val)
        esp_enabled = val
    end
})

ESPTab:AddColorPicker("Box Color", {
    Default = box_color,
    Callback = function(color)
        box_color = color
    end
})

ESPTab:AddColorPicker("Name Color", {
    Default = name_color,
    Callback = function(color)
        name_color = color
    end
})

ESPTab:AddColorPicker("HP Bar Color", {
    Default = hp_color,
    Callback = function(color)
        hp_color = color
    end
})

ESPTab:AddColorPicker("Team Color", {
    Default = team_color,
    Callback = function(color)
        team_color = color
    end
})

ESPTab:AddSlider("Max Distance (studs)", {
    Min = 100,
    Max = 5000,
    Default = esp_max_distance,
    Callback = function(val)
        esp_max_distance = val
        warn("ESP max distance set to: " .. esp_max_distance .. " studs")
    end
})

ESPTab:AddToggle("Team Check", {
    Default = true,
    Callback = function(val)
        esp_team_check = val
    end
})

ESPTab:AddToggle("Visible Check", {
    Default = false,
    Callback = function(val)
        esp_visible_check = val
    end
})

-- Cleanup ESP
Players.PlayerRemoving:Connect(function(player)
    if espElements[player] then
        for _, obj in pairs(espElements[player]) do
            if obj and obj.Remove then obj:Remove() end
        end
        espElements[player] = nil
    end
end)

-- ESP logic
RunService.RenderStepped:Connect(function()
    Camera = getCamera()
    if not esp_enabled or not Camera or not LocalCharacter then
        for _, elements in pairs(espElements or {}) do -- Protect against nil
            for _, obj in pairs(elements or {}) do
                obj.Visible = false
            end
        end
        warn("ESP disabled or invalid state: Camera=" .. tostring(Camera) .. ", LocalCharacter=" .. tostring(LocalCharacter))
        return
    end

    local localRootPart = LocalCharacter:FindFirstChild("HumanoidRootPart")
    if not localRootPart then
        warn("No localRootPart found")
        return
    end
    local localTeam = LocalPlayer.Team
    local localTeamName = localTeam and localTeam.Name or nil
    local localTeamColor = localTeam and localTeam.TeamColor or nil
    local localTeamAttribute = LocalPlayer:GetAttribute("Team") or (LocalPlayer:FindFirstChild("Leaderstats") and LocalPlayer.Leaderstats:FindFirstChild("Team") and LocalPlayer.Leaderstats.Team.Value) or nil
    local localTeamChar = LocalCharacter:FindFirstChild("Team") and LocalCharacter.Team.Value or nil
    local localTeamWorkspace = Workspace:FindFirstChild("Teams") and Workspace.Teams:FindFirstChild(LocalPlayer.Name) and Workspace.Teams[LocalPlayer.Name].Value
    local localAttributes = {}
    local success, attrs = pcall(function() return LocalPlayer:GetAttributes() end)
    if success then
        for k, v in pairs(attrs) do
            if type(v) == "string" or type(v) == "number" or type(v) == "boolean" then
                localAttributes[k] = v
            end
        end
    end
    warn("Local Team: Name=" .. tostring(localTeamName) .. ", Color=" .. tostring(localTeamColor) .. ", Attribute=" .. tostring(localTeamAttribute) .. ", CharTeam=" .. tostring(localTeamChar) .. ", WorkspaceTeam=" .. tostring(localTeamWorkspace) .. ", Attributes=" .. tostring(HttpService:JSONEncode(localAttributes)))

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local character = player.Character
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            local humanoid = character:FindFirstChild("Humanoid")
            local playerTeam = player.Team
            local playerTeamName = playerTeam and playerTeam.Name or nil
            local playerTeamColor = playerTeam and playerTeam.TeamColor or nil
            local playerTeamAttribute = player:GetAttribute("Team") or (player:FindFirstChild("Leaderstats") and player.Leaderstats:FindFirstChild("Team") and player.Leaderstats.Team.Value) or nil
            local playerTeamChar = character:FindFirstChild("Team") and character.Team.Value or nil
            local playerTeamWorkspace = Workspace:FindFirstChild("Teams") and Workspace.Teams:FindFirstChild(player.Name) and Workspace.Teams[player.Name].Value
            local playerAttributes = {}
            local success, attrs = pcall(function() return player:GetAttributes() end)
            if success then
                for k, v in pairs(attrs) do
                    if type(v) == "string" or type(v) == "number" or type(v) == "boolean" then
                        playerAttributes[k] = v
                    end
                end
            end
            warn(player.Name .. " Team: Name=" .. tostring(playerTeamName) .. ", Color=" .. tostring(playerTeamColor) .. ", Attribute=" .. tostring(playerTeamAttribute) .. ", CharTeam=" .. tostring(playerTeamChar) .. ", WorkspaceTeam=" .. tostring(playerTeamWorkspace) .. ", Attributes=" .. tostring(HttpService:JSONEncode(playerAttributes)))
            if rootPart and humanoid then
                local distance = getDistance(Camera.CFrame.Position, rootPart.Position)
                if distance > esp_max_distance then
                    if espElements[player] then
                        for _, obj in pairs(espElements[player] or {}) do
                            obj.Visible = false
                        end
                    end
                    continue
                end

                local isTeammate = false
                if esp_team_check and localTeam and playerTeam then
                    local success, result = pcall(function()
                        return (localTeamName and playerTeamName and localTeamName == playerTeamName) or
                               (localTeamColor and playerTeamColor and localTeamColor == playerTeamColor) or
                               (localTeamAttribute and playerTeamAttribute and localTeamAttribute == playerTeamAttribute) or
                               (localTeamChar and playerTeamChar and localTeamChar == playerTeamChar) or
                               (localTeamWorkspace and playerTeamWorkspace and localTeamWorkspace == playerTeamWorkspace) or
                               (next(localAttributes) and next(playerAttributes) and next(localAttributes) == next(playerAttributes))
                    end)
                    if success and result then
                        isTeammate = true
                    end
                    if isTeammate then
                        if espElements[player] then
                            for _, obj in pairs(espElements[player] or {}) do
                                obj.Visible = false
                            end
                        end
                        warn("ESP skipped: " .. player.Name .. " is teammate (match found)")
                        continue
                    end
                end

                if esp_visible_check and not isVisible(Camera.CFrame.Position, rootPart.Position, character) then
                    if espElements[player] then
                        for _, obj in pairs(espElements[player] or {}) do
                            obj.Visible = false
                        end
                    end
                    warn("ESP skipped: " .. player.Name .. " not visible")
                    continue
                end

                if not espElements[player] then
                    local box = Drawing.new("Square")
                    local nameLabel = Drawing.new("Text")
                    local hpBar = Drawing.new("Square")

                    box.Thickness = 2
                    box.Filled = false
                    box.Transparency = 1
                    box.ZIndex = 1

                    nameLabel.Size = 18
                    nameLabel.Center = true
                    nameLabel.Outline = true
                    nameLabel.Transparency = 1
                    nameLabel.ZIndex = 3

                    hpBar.Filled = true
                    hpBar.Transparency = 1
                    hpBar.ZIndex = 2

                    espElements[player] = {box, nameLabel, hpBar}
                end

                local box, nameLabel, hpBar = unpack(espElements[player])
                local screenPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
                if onScreen then
                    local size = Vector2.new(2000 / screenPos.Z, 2000 / screenPos.Z)
                    local healthPercent = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)

                    box.Size = size
                    box.Position = Vector2.new(screenPos.X - size.X / 2, screenPos.Y - size.Y / 2)
                    box.Color = esp_team_check and (isTeammate and team_color or box_color)
                    box.Visible = true

                    nameLabel.Text = player.Name
                    nameLabel.Position
